/*Implementation of the force histogram using the standard algorithm*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include "util.h"
#include "forcehistogram.h"

/*
Compute the segments that generated by intersecting a straight line with a raster object.
p_seg is a segment array recording a number of segments generated from the intersection.
p_object is the 2D array of the raster object.
p_line and p_offset defines a rasterized straight line.
p_start and p_end are the ends of the minimum bounding rectangle of the object.
p_n is the size of the image.
p_d indicate whether the line is close to the horizontal direction or the vertical direction:
p_d = 1: the line is close to the horizontal direction;
p_d = 0: the line is close to the vertical direction.

*/
int getSegments(SEGMENT * p_seg, double ** p_obj, int * p_line, int p_offset, int p_start, int p_end, int p_n, int p_d)
{
	int count = 0;
	int in_obj = 0;
	int i,j;

	if(!p_d)
	{
		for(j = p_start; j <= p_end; j++)
		{
			i = p_line[j] + p_offset;
			if( i < 0 || i>= p_n)
			{
				if(in_obj)
				{
					p_seg[count].end = (double)j - 1;
					p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
					in_obj = 0;
					count ++;
				}
				continue;
			}
			if(p_obj[i][j] > 0.0)
			{
				if(!in_obj)
				{
					p_seg[count].start = (double)j;
					in_obj = 1;
				}
			}
			else
			{
				if(in_obj)
				{
					p_seg[count].end = (double)j - 1;
					p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
					in_obj = 0;
					count ++;
				}
			}
		}
		if(in_obj)
		{
			p_seg[count].end = (double)j - 1;
			p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
			count ++;
		}
	}
	else
	{
		for(j = p_start; j <= p_end; j++)
		{
			i = p_line[j] + p_offset;
			if( i < 0 || i>= p_n)
			{
				if(in_obj)
				{
					p_seg[count].end = (double)j - 1;
					p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
					in_obj = 0;
					count ++;
				}
				continue;
			}
			if(p_obj[j][i] > 0.0)
			{
				if(!in_obj)
				{
					p_seg[count].start = (double)j;
					in_obj = 1;
				}
			}
			else
			{
				if(in_obj)
				{
					p_seg[count].end = (double)j - 1;
					p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
					in_obj = 0;
					count ++;
				}
			}
		}
		if(in_obj)
		{
			p_seg[count].end = (double)j - 1;
			p_seg[count].length = p_seg[count].end - p_seg[count].start + 1;
			count ++;
		}

	}
	return count;
}

/*
reverse the direcions of the generated segments for using them to compute the forces along the
opposite direction.
*/

int reverseSegments(SEGMENT * p_seg, int p_n)
{
	int i;
	double temp;
	for(i = 0;i < p_n; i++)
	{
		temp = p_seg[i].start;
		p_seg[i].start = -1.0 * p_seg[i].end;
		p_seg[i].end = -1.0 * temp;
	}
	return 1;
}

/*
Old implementation not used by the current application.

Compute the force between two objects along a straight line.
The force is computed as the sum of all the forces between each pair of segments.

p_seg_a: is the array of segments of object A (reference object).
p_seg_b: is the array of segments of object B (argument object).
p_a: is the number of segments in the array of A
p_b: is the number of segments in the array of B

f: is the formula for computing the force between two segments.
*/

double segmentForce(SEGMENT * p_seg_a, SEGMENT * p_seg_b, int p_a, int p_b, double (*f)(double x, double y, double z))
{
	int i;
	int j;
	double value = 0.0;
	double x, y, z, end;
	for( i = 0; i < p_a; i++)
	{
		x = p_seg_a[i].length;
		end = p_seg_a[i].end;
		for( j =0; j < p_b; j++)
		{
			z = p_seg_b[j].length;
			y = p_seg_b[j].start - end - 1;
			value = value + f(x, y, z);
		}
	}
	return value;
}

/*
Compute the force between two objects along a straight line.
The force is computed as the sum of all the forces between each pair of segments.

p_seg_a: is the array of segments of object A (reference object).
p_seg_b: is the array of segments of object B (argument object).
p_a: is the number of segments in the array of A
p_b: is the number of segments in the array of B

r_t: is the type of the force considered, r_t is a real number.
f: is the formula for computing the force between two segments.
*/

double segmentForce_new(SEGMENT * p_seg_a, SEGMENT * p_seg_b, int p_a, int p_b, double r_t, double (*f)(double x, double y, double z, double r))
{
	int i;
	int j;
	double value = 0.0;
	double x, y, z, end;
	for( i = 0; i < p_a; i++)
	{
		x = p_seg_a[i].length;
		end = p_seg_a[i].end;
		for( j =0; j < p_b; j++)
		{
			z = p_seg_b[j].length;
			y = p_seg_b[j].start - end - 1;
			value = value + f(x, y, z, r_t);
		}
	}
	return value;
}

/*
Old implementation not used by the current application.

Compute the force histogram between two raster objects.

histogram: records the result force histogram.
p_d: the number of reference directions considered.
F: the formula of computing the force between two segments.
p_obj_a: the raster object A
box_a: the minimum bounding rectangle of A.
segment_a: the array for storing the segments fetched along each straight line.

p_obj_b: the raster object B.
box_b: the minimum bounding rectangle of B.
segment_b: the array for storing the segments fetched along each straight line.
*/

void force_histogram(double * histogram, int p_d, double (*F)(double x, double y, double z), int * line, int rows, int cols, double p_f, 
						 RAS_OBJ * p_obj_a, BOUND_BOX * box_a, SEGMENT * segment_a,
						 RAS_OBJ * p_obj_b, BOUND_BOX * box_b, SEGMENT * segment_b)
{

	double step_angle = 360.0 / (double) p_d;
	int d_8 = p_d / 8;
	int d_2 = p_d / 2;
	int i,j, pos, rev_pos;
	double ** a_re = p_obj_a->re;
	double ** b_re = p_obj_b->re;
	double tan_value;
	double angle, l_angle;
	double pi = acos(-1.0);
	int start_a, end_a, start_b, end_b, start, end, s_a, s_b;
	double value, reverse_value, factor = 1.0;

	for(i = -1 * d_8; i<= d_8; i++)
	{
		value = 0.0;
		reverse_value = 0.0;

		angle = (double)i * step_angle;
		l_angle = angle * pi / 180.0;

		if(angle == -45)
			tan_value = -1.0;
		else
		{
			if(angle == 45)
				tan_value = 1.0;
			else
				tan_value = tan(l_angle);
		}
		factor = cos(l_angle);
		if(F == F0)
			factor = 1.0 / factor;

		populateLine(line,tan_value,cols);
		if(angle>=0)
		{
			projection(&start_a, &end_a,box_a->v3, box_a->v1, tan_value, 0);
			projection(&start_b, &end_b,box_b->v3, box_b->v1, tan_value, 0);
			pos = i;
		}
		else
		{
			projection(&start_a, &end_a,box_a->v2, box_a->v4, tan_value, 0);
			projection(&start_b, &end_b,box_b->v2, box_b->v4, tan_value, 0);
			pos = i + p_d;
		}
		rev_pos = i + d_2;

		start = start_a > start_b ? start_a : start_b;
		end = end_a < end_b ? end_a : end_b;
		for( j = start; j <= end; j++)
		{
			s_a = getSegments(segment_a, a_re, line, j, box_a->v1[1], box_a->v3[1], rows, 0);
			s_b = getSegments(segment_b, b_re, line, j, box_b->v1[1], box_b->v3[1], rows, 0);
			if(s_a > 0 && s_b > 0)
			{
				value = value + segmentForce(segment_a,segment_b,s_a,s_b,F);

				reverseSegments(segment_a,s_a);
				reverseSegments(segment_b,s_b);

				reverse_value = reverse_value + segmentForce(segment_a,segment_b,s_a,s_b,F);
			}
		}
		histogram[pos] += (value * factor * p_f);
		histogram[rev_pos] += (reverse_value * factor * p_f);
	}

	for( i = d_8 + 1; i< (d_2 - d_8); i++)
	{
		value = 0.0;
		reverse_value = 0.0;

		angle = 90.0 - (double)i * step_angle;
		l_angle = angle * pi / 180.0;
		tan_value = tan( l_angle);
		factor = cos(l_angle);
		if(F == F0)
			factor = 1.0 / factor;
		populateLine(line,tan_value,rows);
		if(angle>=0)
		{
			projection(&start_a, &end_a,box_a->v1, box_a->v3, tan_value, 1);
			projection(&start_b, &end_b,box_b->v1, box_b->v3, tan_value, 1);
		}
		else
		{
			projection(&start_a, &end_a,box_a->v2, box_a->v4, tan_value, 1);
			projection(&start_b, &end_b,box_b->v2, box_b->v4, tan_value, 1);
		}
		pos = i;
		rev_pos = i + d_2;

		start = start_a > start_b ? start_a : start_b;
		end = end_a < end_b ? end_a : end_b;
		for( j = start; j <= end; j++)
		{
			s_a = getSegments(segment_a, a_re, line, j, box_a->v3[0], box_a->v1[0], cols, 1);
			s_b = getSegments(segment_b, b_re, line, j, box_b->v3[0], box_b->v1[0], cols, 1);
			
			if(s_a > 0 && s_b > 0)
			{
				value = value + segmentForce(segment_a,segment_b,s_a,s_b,F);

				reverseSegments(segment_a,s_a);
				reverseSegments(segment_b,s_b);

				reverse_value = reverse_value + segmentForce(segment_a,segment_b,s_a,s_b,F);
			}
		}
		histogram[pos] += (value * factor * p_f);
		histogram[rev_pos] += (reverse_value * factor * p_f);
	}
}

/*

Compute the force histogram between two raster objects.

histogram: records the result force histogram.
p_d: the number of reference directions considered.
r_t: the type of forces considered, r_t is any real number.
F: the formula of computing the force between two segments.
p_obj_a: the raster object A
box_a: the minimum bounding rectangle of A.
segment_a: the array for storing the segments fetched along each straight line.

p_obj_b: the raster object B.
box_b: the minimum bounding rectangle of B.
segment_b: the array for storing the segments fetched along each straight line.
*/

void force_histogram_new(double * histogram, int p_d, double r_t, double (*F)(double x, double y, double z, double r), int * line, int rows, int cols, double p_f, 
						 RAS_OBJ * p_obj_a, BOUND_BOX * box_a, SEGMENT * segment_a,
						 RAS_OBJ * p_obj_b, BOUND_BOX * box_b, SEGMENT * segment_b)
{

	double step_angle = 360.0 / (double) p_d;
	int d_8 = p_d / 8;
	int d_2 = p_d / 2;
	int i,j, pos, rev_pos;
	double ** a_re = p_obj_a->re;
	double ** b_re = p_obj_b->re;
	double tan_value;
	double angle, l_angle;
	double pi = acos(-1.0);
	int start_a, end_a, start_b, end_b, start, end, s_a, s_b;
	double value, reverse_value, factor = 1.0;

	/*Consider the directions in [-pi/4, pi/4], these directions are close to the horizontal direction*/
    for(i = -1 * d_8; i<= d_8; i++)
	{
		value = 0.0;
		reverse_value = 0.0;

		angle = (double)i * step_angle;
		l_angle = angle * pi / 180.0;

		if(angle == -45)
			tan_value = -1.0;
		else
		{
			if(angle == 45)
				tan_value = 1.0;
			else
				tan_value = tan(l_angle);
		}
		factor = pow(cos(l_angle),r_t - 1.0);
		//factor = cos(l_angle);
		//factor = factor / pow(factor,2.0 - r_t);

		/*Rasterize a line along the direction and go through the origin (0,0)*/
        populateLine(line,tan_value,cols);                                                         
		
        /*Project the MBRs of A and B on to the vertical axis according to the current reference direction*/
        if(angle>=0)
		{
			projection(&start_a, &end_a,box_a->v3, box_a->v1, tan_value, 0);    
			projection(&start_b, &end_b,box_b->v3, box_b->v1, tan_value, 0);    
			pos = i;
		}
		else
		{
			projection(&start_a, &end_a,box_a->v2, box_a->v4, tan_value, 0);
			projection(&start_b, &end_b,box_b->v2, box_b->v4, tan_value, 0);
			pos = i + p_d;
		}
		rev_pos = i + d_2;

		start = start_a > start_b ? start_a : start_b;
		end = end_a < end_b ? end_a : end_b;
		
        /*start and end are the ends of the intersection of the two projections*/
        /*the loop fetches all the segments of A and B along a rasterized line and compute the corresponding forces*/
        for( j = start; j <= end; j++)
		{
			s_a = getSegments(segment_a, a_re, line, j, box_a->v1[1], box_a->v3[1], rows, 0); /*Fetch the segments of A*/
			s_b = getSegments(segment_b, b_re, line, j, box_b->v1[1], box_b->v3[1], rows, 0); /*Fecth the segments of B*/
			if(s_a > 0 && s_b > 0)
			{
				value = value + segmentForce_new(segment_a,segment_b,s_a,s_b,r_t,F);          /*compute the forces between the segments*/

				reverseSegments(segment_a,s_a);                                               /*Reverse the direction of the segments of A*/
				reverseSegments(segment_b,s_b);                                               /*Reverse the direction of the segments of B*/

				/*Compute the forces between the reversed segments, this considers the opposite of the current reference direction*/
                reverse_value = reverse_value + segmentForce_new(segment_a,segment_b,s_a,s_b,r_t,F);
			}
		}
		/*Adjust the force values*/
        histogram[pos] += (value * factor * p_f);                                                   
		histogram[rev_pos] += (reverse_value * factor * p_f);
	}

	/*Consider the directions in [pi/4, 3pi/4], these directions are close to the vertical direction*/
    for( i = d_8 + 1; i< (d_2 - d_8); i++)
	{
		value = 0.0;
		reverse_value = 0.0;

		angle = 90.0 - (double)i * step_angle;
		l_angle = angle * pi / 180.0;
		tan_value = tan( l_angle);
		factor = pow(cos(l_angle),r_t - 1.0);
		//factor = cos(l_angle);
		//factor = factor / pow(factor,2.0 - r_t);
		populateLine(line,tan_value,rows);
		
        /*Project the MBRs of A and B on to the horizontal axis according to the current reference direction*/
        if(angle>=0)
		{
			projection(&start_a, &end_a,box_a->v1, box_a->v3, tan_value, 1);
			projection(&start_b, &end_b,box_b->v1, box_b->v3, tan_value, 1);
		}
		else
		{
			projection(&start_a, &end_a,box_a->v2, box_a->v4, tan_value, 1);
			projection(&start_b, &end_b,box_b->v2, box_b->v4, tan_value, 1);
		}
		pos = i;
		rev_pos = i + d_2;

		start = start_a > start_b ? start_a : start_b;
		end = end_a < end_b ? end_a : end_b;
		for( j = start; j <= end; j++)
		{
			s_a = getSegments(segment_a, a_re, line, j, box_a->v3[0], box_a->v1[0], cols, 1);
			s_b = getSegments(segment_b, b_re, line, j, box_b->v3[0], box_b->v1[0], cols, 1);
			
			if(s_a > 0 && s_b > 0)
			{
				value = value + segmentForce_new(segment_a,segment_b,s_a,s_b,r_t,F);

				reverseSegments(segment_a,s_a);
				reverseSegments(segment_b,s_b);

				reverse_value = reverse_value + segmentForce_new(segment_a,segment_b,s_a,s_b,r_t,F);
			}
		}
		histogram[pos] += (value * factor * p_f);
		histogram[rev_pos] += (reverse_value * factor * p_f);
	}
}
/*
Old implementation of force histogram.
*/
double * forceHistogram(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double (*F)(double x, double y, double z))
{
	int rows, cols, max;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	SEGMENT * segment_a, * segment_b;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	if((box_a = loadBoundBox(p_obj_a)) == NULL)
		return histogram;
	if((box_b = loadBoundBox(p_obj_b)) == NULL)
	{
		free(box_b);
		return histogram;
	}

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));

	
	
	force_histogram(histogram, p_d, F, line, rows, cols, 1.0, p_obj_a, box_a,segment_a,p_obj_b,box_b,segment_b);

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	return histogram;
}

/*
Current implementation of the force histogram, it calls the force_histogram_new functin.
In the main function, we call this function to calculate the force histogram between two (crisp) raster objects.

p_d: the number of reference directions considered.
p_obj_a: the raster object A (reference object).
p_obj_b: the raster object B (argument object).

r_t: the type of forces considered.
F: the formula for computing the forces between two segments.
*/

double * forceHistogram_new(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double r_t, double (*F)(double x, double y, double z, double r))
{
	int rows, cols, max;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	SEGMENT * segment_a, * segment_b;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	if((box_a = loadBoundBox(p_obj_a)) == NULL)
		return histogram;
	if((box_b = loadBoundBox(p_obj_b)) == NULL)
	{
		free(box_b);
		return histogram;
	}

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));

	
	
	force_histogram_new(histogram, p_d, r_t, F, line, rows, cols, 1.0, p_obj_a, box_a,segment_a,p_obj_b,box_b,segment_b);

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	return histogram;
}

/*
Old implementation not used any more.
*/

double * forceHistogram_double(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double (*F)(double x, double y, double z))
{
	int rows, cols, max, i, j;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	RAS_OBJ * cut_a, * cut_b;
	SEGMENT * segment_a, * segment_b;
	A_LIST * list_a, * list_b;
	ALPHA * p_a, * p_b;
	double before_a = 0.0;
	double before_b = 0.0;
	double current_a, current_b;
	double p_f;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	box_a = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	box_b = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	
	list_a = createAList();
	detectAlphas(p_obj_a, list_a);
	list_b = createAList();
	detectAlphas(p_obj_b,list_b);

	cut_a = createRasObj(rows,cols,0,0);
	cut_b = createRasObj(rows,cols,0,0);

	p_a = list_a->head;
	for(i = 0; i < list_a->n; i++)
	{
		current_a = p_a->f;
		getAlphaCut(p_obj_a,cut_a,current_a);
		boundBox(box_a, cut_a);
		p_b = list_b->head;
		for(j = 0; j < list_b->n; j++)
		{
			current_b = p_b->f;
			getAlphaCut(p_obj_b,cut_b,current_b);
			boundBox(box_b, cut_b);
			p_f = (current_a - before_a) * (current_b - before_b);
			force_histogram(histogram, p_d, F, line, rows, cols, p_f, cut_a, box_a,segment_a,cut_b,box_b,segment_b);
			before_b = current_b;
			p_b = p_b->next;
		}
		before_b = 0.0;
		before_a = current_a;
		p_a = p_a->next;
	}

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	destroyAList(list_a);
	destroyAList(list_b);
	destroyRasObj(cut_a);
	destroyRasObj(cut_b);
	return histogram;
}

/*
The current implementation of force histogram between two fuzzy raster objects
using double sum scheme.
*/

double * forceHistogram_double_new(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double r_t, double (*F)(double x, double y, double z, double r))
{
	int rows, cols, max, i, j;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	RAS_OBJ * cut_a, * cut_b;
	SEGMENT * segment_a, * segment_b;
	A_LIST * list_a, * list_b;
	ALPHA * p_a, * p_b;
	double before_a = 0.0;
	double before_b = 0.0;
	double current_a, current_b;
	double p_f;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	box_a = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	box_b = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	
	list_a = createAList();
	detectAlphas(p_obj_a, list_a);
	list_b = createAList();
	detectAlphas(p_obj_b,list_b);

	cut_a = createRasObj(rows,cols,0,0);
	cut_b = createRasObj(rows,cols,0,0);

	p_a = list_a->head;
	for(i = 0; i < list_a->n; i++)
	{
		current_a = p_a->f;
		getAlphaCut(p_obj_a,cut_a,current_a);
		boundBox(box_a, cut_a);
		p_b = list_b->head;
		for(j = 0; j < list_b->n; j++)
		{
			current_b = p_b->f;
			getAlphaCut(p_obj_b,cut_b,current_b);
			boundBox(box_b, cut_b);
			p_f = (current_a - before_a) * (current_b - before_b);
			force_histogram_new(histogram, p_d, r_t, F, line, rows, cols, p_f, cut_a, box_a,segment_a,cut_b,box_b,segment_b);
			before_b = current_b;
			p_b = p_b->next;
		}
		before_b = 0.0;
		before_a = current_a;
		p_a = p_a->next;
	}

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	destroyAList(list_a);
	destroyAList(list_b);
	destroyRasObj(cut_a);
	destroyRasObj(cut_b);
	return histogram;
}

/*
Old Implementation not used any more.
*/

double * forceHistogram_single(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double (*F)(double x, double y, double z), int type)
{
	int rows, cols, max, i;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	RAS_OBJ * cut_a, * cut_b;
	SEGMENT * segment_a, * segment_b;
	A_LIST * list;
	ALPHA * p;
	double before = 0.0;
	double current;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	box_a = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	box_b = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	
	list = createAList();
	switch(type)
	{
	case A:
		detectAlphas(p_obj_a,list);
		break;
	case B:
		detectAlphas(p_obj_b,list);
		break;
	case AB:
		detectAlphas(p_obj_a,list);
		detectAlphas(p_obj_b,list);
		break;
	}

	cut_a = createRasObj(rows,cols,0,0);
	cut_b = createRasObj(rows,cols,0,0);

	p = list->head;
	for(i = 0; i < list->n; i++)
	{
		current = p->f;
		getAlphaCut(p_obj_a,cut_a,current);
		getAlphaCut(p_obj_b,cut_b,current);
		if(boundBox(box_a, cut_a) && boundBox(box_b, cut_b))
		{
			force_histogram(histogram, p_d, F, line, rows, cols, (current - before), cut_a, box_a,segment_a,cut_b,box_b,segment_b);		
		}
		before = current;
		p = p->next;
	}

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	destroyAList(list);
	destroyRasObj(cut_a);
	destroyRasObj(cut_b);
	return histogram;
}

/*
Current implementation of force histogram between two fuzzy raster objects
using single sum scheme.
*/

double * forceHistogram_single_new(int p_d, RAS_OBJ * p_obj_a, RAS_OBJ * p_obj_b, double r_t, double (*F)(double x, double y, double z, double r), int type)
{
	int rows, cols, max, i;
	double * histogram;
	int * line;
	BOUND_BOX * box_a, * box_b;
	RAS_OBJ * cut_a, * cut_b;
	SEGMENT * segment_a, * segment_b;
	A_LIST * list;
	ALPHA * p;
	double before = 0.0;
	double current;

	rows = p_obj_a->rows;
	cols = p_obj_a->cols;
	
	histogram = (double *) calloc (p_d, sizeof(double));

	max = rows > cols ? rows:cols;

	line = (int *) calloc (max,sizeof(int));

	segment_a = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	segment_b = (SEGMENT *) calloc (max, sizeof(SEGMENT));
	box_a = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	box_b = (BOUND_BOX *) malloc (sizeof(BOUND_BOX));
	
	list = createAList();
	switch(type)
	{
	case A:
		detectAlphas(p_obj_a,list);
		break;
	case B:
		detectAlphas(p_obj_b,list);
		break;
	case AB:
		detectAlphas(p_obj_a,list);
		detectAlphas(p_obj_b,list);
		break;
	}

	cut_a = createRasObj(rows,cols,0,0);
	cut_b = createRasObj(rows,cols,0,0);

	p = list->head;
	for(i = 0; i < list->n; i++)
	{
		current = p->f;
		getAlphaCut(p_obj_a,cut_a,current);
		getAlphaCut(p_obj_b,cut_b,current);
		if(boundBox(box_a, cut_a) && boundBox(box_b, cut_b))
		{
			force_histogram_new(histogram, p_d, r_t, F, line, rows, cols, (current - before), cut_a, box_a,segment_a,cut_b,box_b,segment_b);		
		}
		before = current;
		p = p->next;
	}

	free(line);
	free(segment_a);
	free(segment_b);
	free(box_a);
	free(box_b);
	destroyAList(list);
	destroyRasObj(cut_a);
	destroyRasObj(cut_b);
	return histogram;
}



/*
int main(int argc, char * argv[])
{
	int p_d;
	int grey_A, grey_B, grey_A_B, m;
	float f;
	FILE * fp = NULL;
	double * histogram;
	IMAGE * image;
	RAS_OBJ * obj_a;
	RAS_OBJ * obj_b;
	double (* F)(double x, double y, double z, double r);

	clock_t tv1, tv2;
	double time = 0.0;

	if(argc < 9)
	{
		printf("parameters: file_name A B A_B d f m his_file\n");
		return 0;
	}

	image = loadImage(argv[1]);
	sscanf(argv[2],"%d", &grey_A);
	sscanf(argv[3],"%d", &grey_B);
	sscanf(argv[4],"%d", &grey_A_B);
	sscanf(argv[5],"%d", &p_d);
	sscanf(argv[6],"%f", &f);
	sscanf(argv[7],"%d", &m);

	obj_a = image2RasObjExtract(image,grey_A,grey_A_B);
	obj_b = image2RasObjExtract(image,grey_B,grey_A_B);

	if(f<1.0)
		F = F_less_1;
	else
	{
		if(f==1.0)
			F = F_1;
		else
		{
			if(f < 2.0)
				F = F_1_2;
			else
			{
				if(f == 2.0)
					F = F_2;
				else
					F = F_bigger_2;
			}
		}
	}
	if(m>0)
	{
		randomFuzzify(obj_a, 100, m);
		randomFuzzify(obj_b, 200, m);

		tv1 = clock();
		histogram = forceHistogram_double_new(p_d,obj_a,obj_b,f,F);
		tv2 = clock();
		time = (((double)(tv2 - tv1)/(CLOCKS_PER_SEC / (double) 1000.0))/1000.0);
	}

	else
	{
		tv1 = clock();
		histogram = forceHistogram_new(p_d,obj_a,obj_b,f,F);
		tv2 = clock();
		time = (((double)(tv2 - tv1)/(CLOCKS_PER_SEC / (double) 1000.0))/1000.0);
	}

	printf("Force Histogram (double):\n");
	printf("Computational time (seconds) is : %f\n", time);

	fp = fopen(argv[8], "w");
	histogramWrite(fp,histogram,p_d);
	fclose(fp);
	destroyRasObj(obj_a);
	destroyRasObj(obj_b);
	destroyImage(image);
	free(histogram);
	return 1;
}*/

/*Main function computing force histogram between two (fuzzy) raster objects*/

int main(int argc, char * argv[])
{
	int p_d;
	float r;
	int d_or_s;
	FILE * fp = NULL;
	double * histogram;
	IMAGE * image_a;
	IMAGE * image_b;
	RAS_OBJ * obj_a;
	RAS_OBJ * obj_b;
	double (* F)(double x, double y, double z, double r);

	clock_t tv1, tv2;
	double time = 0.0;

	if(argc < 7)
	{
		printf("\nThe standard algorithm for computing force histograms\n\n");
        printf("parameters: file_name_A file_name_B d r d_or_s(0/1) histogram_file\n\n");
		printf("file_name_A: the pgm image of object A (reference object);\n");
		printf("file_name_B: the pgm image of object B (argument object);\n");
		printf("d: the number of reference directions considered (integer);\n");
		printf("r: the type of forces (0: constant forces; 2:gravitational forces; or other real numbers);\n");
		printf("d_or_s: integer: 0: consider double sum scheme; 1: consider single sum scheme;\n");
		printf("histogram_file: the txt file for storing the histogram values;\n");
		return 0;
	}

	image_a = loadImage(argv[1]);            /*Load PGM image containing the raster object A*/
	image_b = loadImage(argv[2]);            /*Load PGM image containing the raster object B*/

	sscanf(argv[3],"%d", &p_d);              /*The number of reference directions*/
	sscanf(argv[4],"%f", &r);                /*The type of forces*/
	sscanf(argv[5],"%d", &d_or_s);           /*using double scheme or single scheme*/

	obj_a = image2RasObj(image_a);           /*Load raster object A from the Image*/
	obj_b = image2RasObj(image_b);           /*Load raster object B from the Image*/

	/*
    According to the type of force, deciding which formula we should use to compute the forces
    between two segments.
    */
    if(r<1.0)
		F = F_less_1;
	else
	{
		if(r==1.0)
			F = F_1;
		else
		{
			if(r < 2.0)
				F = F_1_2;
			else
			{
				if(r == 2.0)
					F = F_2;
				else
					F = F_bigger_2;
			}
		}
	}
	
	if(d_or_s == 0)
	{
        /*Force histogram computation using double sum scheme*/
		tv1 = clock();
		histogram = forceHistogram_double_new(p_d,obj_a,obj_b,r,F);
		tv2 = clock();
		time = (((double)(tv2 - tv1)/(CLOCKS_PER_SEC / (double) 1000.0))/1000.0);
	}

	else
	{
		/*Force histogram computation using single sum scheme*/
        tv1 = clock();
		histogram = forceHistogram_single_new(p_d,obj_a,obj_b,r,F,AB);
		tv2 = clock();
		time = (((double)(tv2 - tv1)/(CLOCKS_PER_SEC / (double) 1000.0))/1000.0);
	}

	printf("Force Histogram (double):\n");
	printf("Computational time (seconds) is : %f\n", time);

	fp = fopen(argv[6], "w");
	histogramWrite(fp,histogram,p_d);                /*Write the histogram into a txt file*/
	fclose(fp);
	destroyRasObj(obj_a);
	destroyRasObj(obj_b);
	destroyImage(image_a);
	destroyImage(image_b);
	free(histogram);
	return 1;
}

